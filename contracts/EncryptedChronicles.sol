// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32, euint64, externalEuint32, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {SepoliaConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title Encrypted Purchase Ledger
/// @notice Stores encrypted purchase records where only the purchaser can decrypt them
contract EncryptedChronicles is SepoliaConfig {
    struct PurchaseRecord {
        euint32 itemId;
        euint32 quantity;
        euint64 unitPrice;
        uint64 timestamp;
    }

    mapping(address => PurchaseRecord[]) private _purchaseRecords;

    event PurchaseRecorded(address indexed user, uint256 indexed index, uint64 timestamp);

    /// @notice Records a new encrypted purchase entry for the caller
    /// @param itemIdHandle encrypted item identifier handle
    /// @param quantityHandle encrypted quantity handle
    /// @param unitPriceHandle encrypted unit price handle
    /// @param inputProof proof generated by the relayer for the provided handles
    function recordPurchase(
        externalEuint32 itemIdHandle,
        externalEuint32 quantityHandle,
        externalEuint64 unitPriceHandle,
        bytes calldata inputProof
    ) external {
        euint32 itemId = FHE.fromExternal(itemIdHandle, inputProof);
        euint32 quantity = FHE.fromExternal(quantityHandle, inputProof);
        euint64 unitPrice = FHE.fromExternal(unitPriceHandle, inputProof);

        PurchaseRecord memory record = PurchaseRecord({
            itemId: itemId,
            quantity: quantity,
            unitPrice: unitPrice,
            timestamp: uint64(block.timestamp)
        });

        PurchaseRecord[] storage userRecords = _purchaseRecords[msg.sender];
        userRecords.push(record);
        uint256 recordIndex = userRecords.length - 1;

        FHE.allowThis(record.itemId);
        FHE.allowThis(record.quantity);
        FHE.allowThis(record.unitPrice);

        FHE.allow(record.itemId, msg.sender);
        FHE.allow(record.quantity, msg.sender);
        FHE.allow(record.unitPrice, msg.sender);

        emit PurchaseRecorded(msg.sender, recordIndex, record.timestamp);
    }

    /// @notice Returns the number of purchase records stored for a user
    function getPurchaseCount(address user) external view returns (uint256) {
        return _purchaseRecords[user].length;
    }

    /// @notice Indicates whether a user has recorded purchases
    function hasPurchases(address user) external view returns (bool) {
        return _purchaseRecords[user].length > 0;
    }

    /// @notice Returns a single encrypted purchase record for the given user and index
    function getPurchaseRecord(address user, uint256 index) external view returns (PurchaseRecord memory) {
        require(index < _purchaseRecords[user].length, "Invalid purchase index");
        return _purchaseRecords[user][index];
    }

    /// @notice Returns the latest encrypted purchase for the given user
    function getLatestPurchase(address user) external view returns (PurchaseRecord memory) {
        uint256 length = _purchaseRecords[user].length;
        require(length > 0, "No purchases recorded");
        return _purchaseRecords[user][length - 1];
    }

    /// @notice Returns all encrypted purchase records for the given user
    function getPurchaseRecords(address user) external view returns (PurchaseRecord[] memory) {
        PurchaseRecord[] storage stored = _purchaseRecords[user];
        uint256 length = stored.length;
        PurchaseRecord[] memory copy = new PurchaseRecord[](length);

        for (uint256 i = 0; i < length; i++) {
            copy[i] = stored[i];
        }

        return copy;
    }
}
